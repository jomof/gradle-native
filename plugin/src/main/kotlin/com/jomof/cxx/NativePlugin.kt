/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.jomof.cxx

import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.artifacts.Configuration
import java.io.File
import java.io.OutputStream
import java.util.concurrent.Callable

fun Project.assertProjectConfigurationsNotResolved(message : () -> String = { "" }) {
    configurations.forEach { configuration: Configuration ->
        if (configuration.isCanBeResolved) {
            if (configuration.state == Configuration.State.RESOLVED) {
              error("$configuration was resolved ${message()}")
            }
        }
    }
}

/**
 * A simple 'hello world' plugin.
 */
class NativePlugin: Plugin<Project> {
    override fun apply(project: Project) {
        val cxx = project.extensions.create("cxx", NativePluginExtension::class.java, project)
        project.assertProjectConfigurationsNotResolved()

        project.afterEvaluate {
            // Key is output, value is task name or something we can depend on
            val outputs = mutableMapOf<String, String>()
            val cleanFiles = mutableListOf<File>()
            project.assertProjectConfigurationsNotResolved()

            cxx.buildCommands.forEach { buildCommand ->
                if (outputs.containsKey(buildCommand.output)) {
                    error("Output ${buildCommand.output} is already produced by ${outputs.getValue(buildCommand.output)}")
                }
                outputs[buildCommand.output] = taskNameOfOutput(buildCommand.output)
                cleanFiles.add(File(buildCommand.output))
            }

            project.assertProjectConfigurationsNotResolved()

            cxx.buildCommands.forEach { buildCommand ->
                val taskName = taskNameOfOutput(buildCommand.output)
                project.tasks.register(
                    taskName,
                    BuildTask::class.java
                ) { task ->
                    project.assertProjectConfigurationsNotResolved()
                    task.description = buildCommand.description

                    val sourceFiles = mutableListOf<SourceFiles>()

                    buildCommand.flagAliases.forEach { (name, entity) ->
                        sourceFiles.add(SourceFiles(name, entity.getFileCollection(project), entity))
                    }

                    task.parameters.set(
                        BuildCommandParameters(
                            description = buildCommand.description,
                            inputs = project.files(buildCommand.inputs),
                            dependencies = project.objects.fileCollection().from(object : Callable<List<File>> {
                                override fun call(): List<File> = calculateNativeDependencies(project, buildCommand)
                            }),
                            output = project.file(buildCommand.output),
                            command = buildCommand.command,
                            sourceFiles = sourceFiles
                        )
                    )

                    buildCommand.inputs.forEach { input ->
                        val producer = outputs[input]
                        if (producer != null) {
                            task.dependsOn(producer)
                        }
                    }
                }
            }

            val projectDir = project.projectDir
            val cleanTask = project.tasks.findByName("clean") ?: project.tasks.create("clean")
            cleanTask.doFirst {
                cleanFiles.forEach { cleanFile ->
                    val file = projectDir.resolve(cleanFile)
                    if (file.isFile) {
                        println("Cleaning $cleanFile")
                        file.delete()
                    }
                }
            }

            val assembleTask = project.tasks.findByName("assemble") ?: project.tasks.create("assemble")
            assembleTask.dependsOn(project.tasks.withType(BuildTask::class.java))
            project.assertProjectConfigurationsNotResolved()
        }
        project.assertProjectConfigurationsNotResolved()
    }
}

fun taskNameOfOutput(output : String) = output
    .replace('\\', '-')
    .replace('/', '-')

fun calculateNativeDependencies(project: Project, buildCommand: BuildCommand) : List<File> {
    if (buildCommand.depfile.isNullOrEmpty()) return listOf()
    // Not a clang compile
    val depfile = project.projectDir.resolve(buildCommand.depfile)


    val inputs = buildCommand.inputs.map { File(it) }
    if (depfile.isOutOfDateWithRespectTo(inputs)) {
        val tokenList = buildCommand.command.removeMatchingElementAndNext("-include-pch", 1) + listOf("-E")

        // Check whether it's possible a depfile will actually be created
        if (!tokenList.any { it.contains(depfile.name)}) {
            error("Command won't create declared depfile '$depfile':\n${tokenList.joinToString("\n    ")}")
        }
        depfile.parentFile.mkdirs()

        // Run the command with -E flag to execute only preprocessor
        project.exec {
            it.commandLine = tokenList
            it.workingDir = project.projectDir.absoluteFile
            it.standardOutput = OutputStream.nullOutputStream()
            it.errorOutput = OutputStream.nullOutputStream()
            it.isIgnoreExitValue = true
        }

        if (depfile.isOutOfDateWithRespectTo(inputs)) {
           // error("Command didn't create declared depfile '$depfile':\n${tokenList.joinToString("\n    ")}")
            return listOf()
        }
    }

    return depfile.readText()
        .substringAfter(": ")
        .replace('\\', ' ')
        .split(" ")
        .map { it.trim(' ', '\n', '\r') }
        .filter { it.isNotBlank() }
        .map { File(it) }
        .onEach {
            val file = project.projectDir.resolve(it)
            if (!file.isFile) error("Expected '$file' to exist")
        }
}

fun File.isOutOfDateWithRespectTo(files : List<File>) : Boolean {
    if (!isFile) return true
    for (file in files) {
        if (lastModified() < file.lastModified()) return true
    }
    return false
}



