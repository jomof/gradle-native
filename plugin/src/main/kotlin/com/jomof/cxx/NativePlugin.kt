/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.jomof.cxx

import org.gradle.api.Project
import org.gradle.api.Plugin
import org.gradle.api.artifacts.Configuration
import java.io.File
import java.io.OutputStream

/**
 * A simple 'hello world' plugin.
 */
class NativePlugin: Plugin<Project> {
    override fun apply(project: Project) {
        val cxx = project.extensions.create("cxx", NativePluginExtension::class.java, project)

        project.afterEvaluate {
            // Key is output, value is task name or something we can depend on
            val outputs = mutableMapOf<String, Any>()
            val cleanFiles = mutableListOf<File>()

            project.configurations.forEach { configuration : Configuration ->
                if (configuration.isCanBeResolved) {
                    for (file in configuration.resolve()) {
                        outputs[file.path] = configuration
                    }
                }
            }
            val buildCommands = cxx.buildCommands.associateBy { taskNameOfOutput(it.output) }

            buildCommands.forEach { (taskName, ruleScope) ->
                if (outputs.containsKey(ruleScope.output)) {
                    error("Output ${ruleScope.output} is already produced by ${outputs.getValue(ruleScope.output)}")
                }
                outputs[ruleScope.output] = taskName
                cleanFiles.add(File(ruleScope.output))
            }

            buildCommands.forEach { (taskName, buildCommand) ->
                project.tasks.register(
                    taskName,
                    BuildTask::class.java
                ) { task ->

                    task.description = buildCommand.description

                    val nativeDependencies = calculateNativeDependencies(project, buildCommand)

                    task.parameters.set(
                        BuildCommandParameters(
                            description = buildCommand.description,
                            inputs = project.files(buildCommand.inputs),
                            dependencies = nativeDependencies,
                            output = project.file(buildCommand.output),
                            command = buildCommand.command
                        )
                    )
                    buildCommand.inputs.forEach { input ->
                        val producer = outputs[input]
                        if (producer != null) {
                            task.dependsOn(producer)
                        } else {
                            if (!project.file(input).isFile) {
                                error("Input $input did not exist")
                            }
                        }
                    }
                }
            }

            val projectDir = project.projectDir
            project.task("clean").doFirst {
                cleanFiles.forEach { cleanFile ->
                    val file = projectDir.resolve(cleanFile)
                    if (file.isFile) {
                        println("Cleaning $cleanFile")
                        file.delete()
                    }
                }
            }

            project.tasks.register("assemble") {
                it.dependsOn(project.tasks.withType(BuildTask::class.java))
            }
        }
    }
}

fun taskNameOfOutput(output : String) = output
    .replace('\\', '-')
    .replace('/', '-')

fun calculateNativeDependencies(project: Project, buildCommand: BuildCommand) : List<File> {
    if (buildCommand.depfile.isNullOrEmpty()) return listOf()
    // Not a clang compile
    val depfile = project.projectDir.resolve(buildCommand.depfile)


    val inputs = buildCommand.inputs.map { File(it) }
    if (depfile.isOutOfDateWithRespectTo(inputs)) {
        val tokenList = buildCommand.command.removeMatchingElementAndNext("-include-pch", 1)

        // Check whether it's possible a depfile will actually be created
        if (!tokenList.any { it.contains(depfile.name)}) {
            error("Command won't create declared depfile '$depfile':\n${tokenList.joinToString("\n    ")}")
        }
        depfile.parentFile.mkdirs()

        // Run the command with -E flag to execute only preprocessor
        //println(tokenList.joinToString("\n  "))
        project.exec {
            it.commandLine = tokenList + listOf("-E")
            it.workingDir = project.projectDir.absoluteFile
            it.standardOutput = OutputStream.nullOutputStream()
            it.errorOutput = OutputStream.nullOutputStream()
            it.isIgnoreExitValue = true
        }

        if (depfile.isOutOfDateWithRespectTo(inputs)) {
           // error("Command didn't create declared depfile '$depfile':\n${tokenList.joinToString("\n    ")}")
            return listOf()
        }
    }

    return depfile.readText()
        .substringAfter(": ")
        .replace('\\', ' ')
        .split(" ")
        .map { it.trim(' ', '\n', '\r') }
        .filter { it.isNotBlank() }
        .map { File(it) }
        .onEach {
            val file = project.projectDir.resolve(it)
            if (!file.isFile) error("Expected '$file' to exist")
        }
}

fun File.isOutOfDateWithRespectTo(files : List<File>) : Boolean {
    if (!isFile) return true
    for (file in files) {
        if (lastModified() < file.lastModified()) return true
    }
    return false
}


